"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const telegraf_1 = require("telegraf");
const filters_1 = require("telegraf/filters");
function checkDreamText(ctx) {
    if (ctx.session?.isUserStartedBot) {
        let messageText = '';
        if (ctx.has((0, filters_1.message)("text"))) {
            messageText = ctx.message.text.replace(new RegExp(`@${ctx.botInfo.username}`, 'g'), '');
        }
        ctx.session.userDream = messageText;
        // check on urls
        const urlRegex = /(https?:\/\/[^\s]+)/g;
        if (urlRegex.test(messageText)) {
            ctx.reply('–ü–æ—Å–∏–ª–∞–Ω–Ω—è –≤ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—ñ –∑–∞–±–æ—Ä–æ–Ω–µ–Ω—ñ\n\n –°–ø—Ä–æ–±—É–π —â–µ —Ä–∞–∑');
            return;
        }
        // check symbol count
        if (messageText.length <= 100) {
            ctx.reply('–¢–≤—ñ–π —Å–æ–Ω –ø–æ–≤–∏–Ω–µ–Ω –±—É—Ç–∏ –±—ñ–ª—å—à–µ 100 —Å–∏–º–≤–æ–ª—ñ–≤(\n\n –°–ø—Ä–æ–±—É–π —â–µ —Ä–∞–∑');
            return;
        }
        // check bed worlds
        const badWorlds = ['—Ö–æ—Ö–ª—ã', '–ø–∏–¥–æ—Ä', '–ø–∏–¥–æ—Ä–∞—Å', '–ø–∏–¥—Ä–∏–ª–∞', '–ø—ñ–¥–æ—Ä', '–Ω—ñ–≥–µ—Ä', '–Ω—ñ–≥–∞', 'www', 'com'];
        const hasHaveBadWorld = badWorlds.find(world => messageText.includes(world));
        if (hasHaveBadWorld) {
            ctx.replyWithHTML(`–í —Ç–µ–∫—Å—Ç—ñ —Å–Ω—É –Ω–µ –ø–æ–≤–∏–Ω–Ω–æ –±—É—Ç–∏ –ø–æ–≥–∞–Ω–∏—Ö —Å–ª—ñ–≤, —è–∫ <i>‚Äú${hasHaveBadWorld}‚Äù</i>\n\n –°–ø—Ä–æ–±—É–π —â–µ —Ä–∞–∑`);
            return;
        }
        // check zalgo text
        const hasZalgo = /%CC%/g.test(encodeURIComponent(messageText));
        if (hasZalgo) {
            ctx.replyWithHTML(`–í —Ç–µ–∫—Å—Ç—ñ —Å–Ω—É –Ω–µ –ø–æ–≤–∏–Ω–Ω–æ –±—É—Ç–∏ Zalgo —Ç–µ–∫—Å—Ç—É\n\n –°–ø—Ä–æ–±—É–π —â–µ —Ä–∞–∑`);
            return;
        }
        // check repeated worlds
        if (checkRepeatedInMessage('world', 4, messageText)) {
            ctx.replyWithHTML(`–°–ª–æ–≤–∞ —á–∞—Å—Ç–æ –ø–æ–≤—Ç–æ—Ä—é—é—Ç—å—Å—è –ø—ñ–¥—Ä—è–¥, —Å—Ö–æ–∂–µ –Ω–∞ —Å–ø–∞–º\n\n –°–ø—Ä–æ–±—É–π —â–µ —Ä–∞–∑`);
            return;
        }
        // check repeated symbol
        if (checkRepeatedInMessage('symbol', 8, messageText)) {
            ctx.replyWithHTML(`–ë—É–∫–≤–∏ —á–∞—Å—Ç–æ –ø–æ–≤—Ç–æ—Ä—é—é—Ç—å—Å—è –ø—ñ–¥—Ä—è–¥, —Å—Ö–æ–∂–µ –Ω–∞ —Å–ø–∞–º\n\n –°–ø—Ä–æ–±—É–π —â–µ —Ä–∞–∑`);
            return;
        }
        ctx.replyWithHTML('–¢–∏ —Ö–æ—á–µ—à –∞–Ω–æ–Ω—ñ–º–Ω–æ –ø–æ–¥—ñ–ª–∏—Ç–∏—Å—è –Ω–∞—Å—Ç—É–ø–Ω–∏–º —Å–Ω–æ–º:\n\n' + `<i>‚Äú${messageText}‚Äù</i>\n\n` + '–ß–∏ –≤—Å–µ –≤—ñ—Ä–Ω–æ?', sendEditKeyboard(messageText));
    }
    else {
        ctx.reply('–ù–∞–∂–º—ñ—Ç—å /start —â–æ–± –ø–æ—á–∞—Ç–∏');
    }
}
exports.default = checkDreamText;
function checkRepeatedInMessage(type, brakeCount, message) {
    let stringElement;
    if (type === 'world') {
        stringElement = message.split(' ');
    }
    else if (type === 'symbol') {
        stringElement = message.split('');
    }
    let counter = 1;
    let previousWorld;
    let currentWorld;
    if (stringElement) {
        for (let i = 0; i < stringElement.length; i++) {
            currentWorld = stringElement[i];
            if (previousWorld === currentWorld) {
                counter = counter + 1;
            }
            else {
                counter = 1;
            }
            if (counter === brakeCount) {
                return true;
            }
            previousWorld = currentWorld;
        }
        return false;
    }
    return false;
}
function sendEditKeyboard(dreamText) {
    return telegraf_1.Markup.inlineKeyboard([
        [
            telegraf_1.Markup.button.callback('–¢–∞–∫, –ø—É–±–ª—ñ–∫—É–π—Ç–µ! ü•≥', 'sendDream'),
            telegraf_1.Markup.button.switchToCurrentChat('–†–µ–¥–∞–≥—É–≤–∞—Ç–∏ ‚úçÔ∏è', `${dreamText}`),
        ],
    ]);
}
